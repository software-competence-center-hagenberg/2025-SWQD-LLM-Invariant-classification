pptname;invariant;invariantType;variables;tp;fp;enter;bug
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[]) == size(input.attributes[]);daikon.inv.binary.twoScalar.IntEqual;(size(input.categories[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input != null;daikon.inv.unary.scalar.NonZero;(input);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.open_at == 1663868799;daikon.inv.unary.scalar.OneOfScalar;(input.open_at);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.attributes[]) one of { 1, 2, 3 };daikon.inv.unary.scalar.OneOfScalar;(size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.radius > input.limit;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.limit);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.radius > input.offset;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.radius > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.radius > size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.radius > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.limit != input.offset;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.limit > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.limit != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.limit > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.offset % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.offset > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 % input.offset == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.offset >= size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;input.offset != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[]) != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[]) != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.price[])-1 % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 % size(input.price[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.price[]) != size(input.attributes[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.price[]) >= size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.price[..]), size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.price[])-1 % size(input.attributes[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.price[..])-1, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::ENTER;size(input.price[])-1 != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..])-1, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[]) == size(input.attributes[]);daikon.inv.binary.twoScalar.IntEqual;(size(input.categories[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input != null;daikon.inv.unary.scalar.NonZero;(input);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.open_at == 1663868799;daikon.inv.unary.scalar.OneOfScalar;(input.open_at);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;return != null;daikon.inv.unary.scalar.NonZero;(return);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.attributes[]) one of { 1, 2, 3 };daikon.inv.unary.scalar.OneOfScalar;(size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.radius > input.limit;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.limit);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.radius > input.offset;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.radius > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.radius > size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.radius > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.limit != input.offset;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.limit > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.limit != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.limit > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.offset % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.offset > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 % input.offset == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.offset >= size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;input.offset != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[]) != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[]) != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.price[])-1 % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 % size(input.price[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.price[]) != size(input.attributes[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.price[]) >= size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.price[..]), size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.price[])-1 % size(input.attributes[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.price[..])-1, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses&categories(main.getBusinesses&Input):::EXIT;size(input.price[])-1 != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..])-1, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[]) == size(input.attributes[]);daikon.inv.binary.twoScalar.IntEqual;(size(input.categories[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input != null;daikon.inv.unary.scalar.NonZero;(input);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.open_at == 1663868799;daikon.inv.unary.scalar.OneOfScalar;(input.open_at);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.attributes[]) one of { 1, 2, 3 };daikon.inv.unary.scalar.OneOfScalar;(size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.radius > input.limit;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.limit);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.radius > input.offset;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.radius > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.radius > size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.radius > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.limit != input.offset;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.limit > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.limit != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.limit > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.offset % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.offset > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 % input.offset == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.offset >= size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;input.offset != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[]) != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[]) != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.price[])-1 % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 % size(input.price[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.categories[])-1 != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.price[]) != size(input.attributes[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.price[]) >= size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.price[..]), size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.price[])-1 % size(input.attributes[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.price[..])-1, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::ENTER;size(input.price[])-1 != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..])-1, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[]) == size(input.attributes[]);daikon.inv.binary.twoScalar.IntEqual;(size(input.categories[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input != null;daikon.inv.unary.scalar.NonZero;(input);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.open_at == 1663868799;daikon.inv.unary.scalar.OneOfScalar;(input.open_at);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return != null;daikon.inv.unary.scalar.NonZero;(return);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.categories != null;daikon.inv.unary.scalar.NonZero;(return.categories);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.categories[] elements != null;daikon.inv.unary.sequence.EltNonZero;(return.categories[..]);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates != null;daikon.inv.unary.scalar.NonZero;(return.coordinates);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.latitude != 0;daikon.inv.unary.scalar.NonZeroFloat;(return.coordinates.latitude);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.longitude != 0;daikon.inv.unary.scalar.NonZeroFloat;(return.coordinates.longitude);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.is_closed == false;daikon.inv.unary.scalar.OneOfScalar;(return.is_closed);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.review_count >= 1;daikon.inv.unary.scalar.LowerBound;(return.review_count);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.transactions != null;daikon.inv.unary.scalar.NonZero;(return.transactions);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;"return.transactions[] elements one of { ""delivery"", ""pickup"", ""restaurant_reservation"" }";daikon.inv.unary.stringsequence.EltOneOfString;(return.transactions[..]);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.location != null;daikon.inv.unary.scalar.NonZero;(return.location);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.location.display_address != null;daikon.inv.unary.scalar.NonZero;(return.location.display_address);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.attributes[]) one of { 1, 2, 3 };daikon.inv.unary.scalar.OneOfScalar;(size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(return.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(return.categories[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(return.location.display_address[]) >= 2;daikon.inv.unary.scalar.LowerBound;(size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > input.limit;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.limit);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > input.offset;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > return.review_count;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, return.review_count);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > size(return.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(return.categories[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > size(return.transactions[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(return.transactions[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.radius > size(return.location.display_address[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.limit != input.offset;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.limit > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.limit != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.limit > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.limit >= size(return.categories[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.limit, size(return.categories[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.limit >= size(return.transactions[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.limit, size(return.transactions[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.offset % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.offset > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.offset, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 % input.offset == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(input.offset, size(input.categories[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.offset >= size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.offset != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;input.offset >= size(return.transactions[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(return.transactions[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.latitude != return.coordinates.longitude;daikon.inv.binary.twoScalar.FloatNonEqual;(return.coordinates.latitude, return.coordinates.longitude);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.latitude < return.distance;daikon.inv.binary.twoScalar.FloatLessThan;(return.coordinates.latitude, return.distance);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.latitude != return.rating;daikon.inv.binary.twoScalar.FloatNonEqual;(return.coordinates.latitude, return.rating);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.longitude < return.distance;daikon.inv.binary.twoScalar.FloatLessThan;(return.coordinates.longitude, return.distance);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.coordinates.longitude != return.rating;daikon.inv.binary.twoScalar.FloatNonEqual;(return.coordinates.longitude, return.rating);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.distance > return.rating;daikon.inv.binary.twoScalar.FloatGreaterThan;(return.distance, return.rating);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.review_count >= size(input.price[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(return.review_count, size(input.price[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.review_count >= size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(return.review_count, size(input.attributes[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.review_count > size(return.transactions[]);daikon.inv.binary.twoScalar.IntGreaterThan;(return.review_count, size(return.transactions[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.location.address1 in return.location.display_address[];daikon.inv.binary.sequenceString.MemberString;(return.location.address1, return.location.display_address[..]);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.location.address2 in return.location.display_address[];daikon.inv.binary.sequenceString.MemberString;(return.location.address2, return.location.display_address[..]);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;return.location.address3 in return.location.display_address[];daikon.inv.binary.sequenceString.MemberString;(return.location.address3, return.location.display_address[..]);1;0;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[]) != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[]) != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.price[])-1 % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..]), size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(return.transactions[]) % size(input.categories[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..]), size(return.transactions[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[]) % size(return.transactions[])-1 == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..]), size(return.transactions[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 % size(input.price[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..])-1, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..])-1, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 >= size(return.transactions[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.categories[..])-1, size(return.transactions[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 % size(return.transactions[])-1 == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.categories[..])-1, size(return.transactions[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 <= size(return.location.display_address[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(input.categories[..])-1, size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.price[]) != size(input.attributes[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.price[]) >= size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.price[..]), size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.price[])-1 % size(input.attributes[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.price[..])-1, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.price[])-1 != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..])-1, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.price[])-1 <= size(return.location.display_address[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(input.price[..])-1, size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.attributes[])-1 <= size(return.categories[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(input.attributes[..])-1, size(return.categories[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.attributes[])-1 <= size(return.transactions[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(input.attributes[..])-1, size(return.transactions[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(input.attributes[])-1 <= size(return.location.display_address[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(input.attributes[..])-1, size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(return.categories[])-1 <= size(return.location.display_address[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(return.categories[..])-1, size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200&businesses(main.getBusinesses&Input):::EXIT;size(return.transactions[])-1 <= size(return.location.display_address[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(return.transactions[..])-1, size(return.location.display_address[..]));0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.categories[]) == size(input.attributes[]);daikon.inv.binary.twoScalar.IntEqual;(size(input.categories[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input != null;daikon.inv.unary.scalar.NonZero;(input);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.offset >= 1;daikon.inv.unary.scalar.LowerBound;(input.offset);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.open_at one of { 1663868799, 1664020931 };daikon.inv.unary.scalar.OneOfScalar;(input.open_at);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.price[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.attributes[]) one of { 1, 2, 3 };daikon.inv.unary.scalar.OneOfScalar;(size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.radius > input.limit;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.limit);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.radius > input.offset;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.radius > size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.limit != input.offset;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.limit > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.limit != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.limit > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.offset >= size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;input.offset != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.price[]) != size(input.attributes[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.price[]) >= size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.price[..]), size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.price[])-1 % size(input.attributes[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.price[..])-1, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::ENTER;size(input.price[])-1 != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..])-1, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.categories[]) == size(input.attributes[]);daikon.inv.binary.twoScalar.IntEqual;(size(input.categories[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input != null;daikon.inv.unary.scalar.NonZero;(input);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.offset >= 1;daikon.inv.unary.scalar.LowerBound;(input.offset);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.open_at one of { 1663868799, 1664020931 };daikon.inv.unary.scalar.OneOfScalar;(input.open_at);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return != null;daikon.inv.unary.scalar.NonZero;(return);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.total >= 0;daikon.inv.unary.scalar.LowerBound;(return.total);1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.region != null;daikon.inv.unary.scalar.NonZero;(return.region);1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.region.center != null;daikon.inv.unary.scalar.NonZero;(return.region.center);1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.businesses != null;daikon.inv.unary.scalar.NonZero;(return.businesses);1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.businesses[] elements != null;daikon.inv.unary.sequence.EltNonZero;(return.businesses[..]);1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.categories[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.price[]) >= 1;daikon.inv.unary.scalar.LowerBound;(size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.attributes[]) one of { 1, 2, 3 };daikon.inv.unary.scalar.OneOfScalar;(size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.radius > input.limit;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.limit);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.radius > input.offset;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.radius > return.total;daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, return.total);0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.radius > size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.radius > size(return.businesses[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.radius, size(return.businesses[..]));0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.limit != input.offset;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, input.offset);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.limit > size(input.categories[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.categories[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.limit != size(input.price[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.limit, size(input.price[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.limit > size(input.attributes[]);daikon.inv.binary.twoScalar.IntGreaterThan;(input.limit, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.limit >= size(return.businesses[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.limit, size(return.businesses[..]));1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.offset != return.total;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, return.total);0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.offset >= size(input.price[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(input.offset, size(input.price[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;input.offset != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(input.offset, size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.total != size(input.categories[]);daikon.inv.binary.twoScalar.IntNonEqual;(return.total, size(input.categories[..]));0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.total >= size(input.categories[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(return.total, size(input.categories[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.total != size(input.price[]);daikon.inv.binary.twoScalar.IntNonEqual;(return.total, size(input.price[..]));0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.total >= size(input.price[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(return.total, size(input.price[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.total >= size(return.businesses[]);daikon.inv.binary.twoScalar.IntGreaterEqual;(return.total, size(return.businesses[..]));1;0;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;return.region.center.latitude != return.region.center.longitude;daikon.inv.binary.twoScalar.FloatNonEqual;(return.region.center.latitude, return.region.center.longitude);0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.categories[]) != size(return.businesses[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.categories[..]), size(return.businesses[..])-1);0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.categories[])-1 <= size(return.businesses[]);daikon.inv.binary.twoScalar.IntLessEqual;(size(input.categories[..])-1, size(return.businesses[..]));0;1;0;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.price[]) != size(input.attributes[]);daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..]), size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.price[]) >= size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntGreaterEqual;(size(input.price[..]), size(input.attributes[..])-1);0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.price[])-1 % size(input.attributes[]) == 0;daikon.inv.binary.twoScalar.NumericInt$Divides;(size(input.price[..])-1, size(input.attributes[..]));0;0;1;0
main.businessessearch.getBusinesses&200(main.getBusinesses&Input):::EXIT;size(input.price[])-1 != size(input.attributes[])-1;daikon.inv.binary.twoScalar.IntNonEqual;(size(input.price[..])-1, size(input.attributes[..])-1);0;0;1;0
